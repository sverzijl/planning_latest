============================= test session starts ==============================
platform linux -- Python 3.11.2, pytest-8.4.2, pluggy-1.6.0 -- /home/sverzijl/planning_latest/venv/bin/python
cachedir: .pytest_cache
rootdir: /home/sverzijl/planning_latest
plugins: cov-7.0.0, mock-3.15.1
collecting ... collected 1 item

tests/test_integration_ui_workflow.py::test_ui_workflow_4_weeks_with_initial_inventory 
⚠ No inventory file - using earliest forecast date as planning start: 2025-10-07

================================================================================
DATA SUMMARY
================================================================================
Forecast entries: 17760
Date range: 2025-10-07 to 2026-12-31
Total demand: 5,171,692 units
Locations: 11
Routes: 10
Labor days: 585
Truck schedules: 11

Planning horizon: 2025-10-07 to 2025-11-04 (4 weeks)

================================================================================
OPTIMIZATION SETTINGS
================================================================================
allow_shortages: True
enforce_shelf_life: True
use_batch_tracking: True
max_routes_per_destination: 5
mip_gap: 0.01
time_limit_seconds: 120
solver_name: cbc
start_date: 2025-10-07
end_date: 2025-11-04

================================================================================
MODEL CREATION
================================================================================
✓ Model built in 0.49s
  Routes enumerated: 8
  Planning horizon: 29 days (4.1 weeks)
  Date range: 2025-10-07 to 2025-11-04
  Batch tracking: ENABLED

================================================================================
SOLVING OPTIMIZATION
================================================================================

Building sparse cohort indices...
  Production dates: 29 in horizon + 0 from initial inventory
  Frozen cohorts: 5,820
  Ambient cohorts: 15,125
  Shipment cohorts: 19,615
  Demand cohorts: 8,660
  Freeze/thaw cohorts: 3,645
  Total: 52,865

Validating cohort model structure...
  Cohort variables: 49,220 / 21 total (234381.0%)
  ✓ Cohort model validation passed
✓ Solved in 39.32s

================================================================================
SOLUTION SUMMARY
================================================================================
Status: optimal
Objective value: $1,261,530.08
Solve time: 32.85s
Gap: 0.03%

================================================================================
COST BREAKDOWN
================================================================================
Labor cost:     $    6,002.14
Production cost: $1,134,200.00
Transport cost: $        0.00
Inventory cost: $    8,813.86
Shortage cost:  $  112,514.08
----------------------------------------
TOTAL:          $1,261,530.08

================================================================================
PRODUCTION SUMMARY
================================================================================
Total production: 226,840 units
Production batches: 80
Total labor hours: 162.0h
Average batch size: 2,836 units

================================================================================
DISTRIBUTION SUMMARY
================================================================================
Shipments created: 899
Total shipped: 337,527 units
Destinations served: 10

================================================================================
DEMAND SATISFACTION
================================================================================
Total demand (forecast): 5,171,692 units
Demand in horizon: 248,403 units
Shortage: 11,251 units
Fill rate: 95.5%

================================================================================
PERFORMANCE SUMMARY
================================================================================
Model build time: 0.49s
Solve time: 39.32s
Total time: 39.82s
Status: ✗ SLOW

================================================================================
FIRST & FINAL DAY INVENTORY CHECK
================================================================================
FIRST day (2025-10-07) inventory: 2,204 units
  By location:
    6122_Storage: 1,524 units
    Lineage: 681 units
Final planning date: 2025-11-04
Total inventory on final day: 10,410 units

Inventory by location on final day:
  Lineage: 10,374 units
  6122_Storage: 35 units

Demand after planning horizon (2025-11-04): 4,923,289 units
Model's knowledge of future demand: NONE (only sees 880 demand entries within horizon)

Material Balance Check:
  Production: 226,840 units
  Demand in horizon: 248,403 units
  Shortage (unmet): 11,251 units
  Satisfied demand: 237,152 units
  Final day inventory: 10,410 units
  Shipments after horizon: 0 units
  Total outflow (satisfied + final inv): 247,561 units

  Demand satisfaction validation:
    Method 1 (Forecast - Shortage): 237,152 units
    Method 2 (Cohort Consumption): 237,152 units

  Material balance (using cohort consumption):
    Production: 226,840
    Consumption + Final Inv: 247,561
    Balance: -20,721 units

⚠ MATERIAL BALANCE ISSUE (Method 1 - Forecast-based):
  Production: 226,840
  Total outflow: 247,561
  Difference: -20,721 units

❌ Material balance ALSO wrong with cohort method!
  This indicates a real flow conservation bug in the model

⚠ Model doesn't see future demand, yet holds 10,410 units
  Reason: No end-of-horizon inventory penalty in objective function

================================================================================
TEST PASSED ✓
================================================================================

================================================================================
⚠ ASSERTION FAILURES
================================================================================
  • ⚠ Solve time 39.32s exceeds 30s threshold (performance regression)
FAILED

=================================== FAILURES ===================================
_______________ test_ui_workflow_4_weeks_with_initial_inventory ________________

parsed_data = {'cost_structure': CostStructure(production_cost_per_unit=5.0, setup_cost=0.0, default_regular_rate=25.0, default_over...ce=None)], creation_date=datetime.date(2025, 10, 13)), 'initial_inventory': None, 'inventory_snapshot_date': None, ...}

    def test_ui_workflow_4_weeks_with_initial_inventory(parsed_data):
        """
        Integration test matching UI workflow with 4-week horizon and initial inventory.
    
        This test validates:
        1. Data loading and parsing (forecast, network, inventory)
        2. Model creation with UI-matching parameters
        3. Fast solve time (<30 seconds with 1% gap tolerance)
        4. Feasible solution with demand satisfaction
        5. Initial inventory properly incorporated
        """
    
        # Extract parsed data
        forecast = parsed_data['forecast']
        locations = parsed_data['locations']
        routes = parsed_data['routes']
        labor_calendar = parsed_data['labor_calendar']
        truck_schedules = parsed_data['truck_schedules']
        cost_structure = parsed_data['cost_structure']
        manufacturing_site = parsed_data['manufacturing_site']
        initial_inventory = parsed_data['initial_inventory']
        inventory_snapshot_date = parsed_data['inventory_snapshot_date']
    
        # Validate or set inventory snapshot date
        if inventory_snapshot_date is not None:
            print(f"\n✓ Inventory snapshot date: {inventory_snapshot_date}")
            assert inventory_snapshot_date == date(2025, 10, 13), \
                f"Expected inventory snapshot date 2025-10-13, got {inventory_snapshot_date}"
        else:
            # No inventory file - use earliest forecast date as planning start
            inventory_snapshot_date = min(e.forecast_date for e in forecast.entries)
            print(f"\n⚠ No inventory file - using earliest forecast date as planning start: {inventory_snapshot_date}")
    
        # Print data summary
        print("\n" + "="*80)
        print("DATA SUMMARY")
        print("="*80)
        print(f"Forecast entries: {len(forecast.entries)}")
        print(f"Date range: {min(e.forecast_date for e in forecast.entries)} to {max(e.forecast_date for e in forecast.entries)}")
        print(f"Total demand: {sum(e.quantity for e in forecast.entries):,.0f} units")
        print(f"Locations: {len(locations)}")
        print(f"Routes: {len(routes)}")
        print(f"Labor days: {len(labor_calendar.days)}")
        print(f"Truck schedules: {len(truck_schedules.schedules)}")
    
        if initial_inventory:
            total_init_inventory = sum(initial_inventory.to_optimization_dict().values())
            print(f"Initial inventory: {total_init_inventory:,.0f} units at {inventory_snapshot_date}")
    
        # Calculate 4-week planning horizon from inventory snapshot date
        planning_start_date = inventory_snapshot_date
        planning_end_date = planning_start_date + timedelta(weeks=4)
    
        print(f"\nPlanning horizon: {planning_start_date} to {planning_end_date} (4 weeks)")
    
        # UI SETTINGS (matching Planning Tab)
        settings = {
            'allow_shortages': True,              # ✓ Allow Demand Shortages
            'enforce_shelf_life': True,           # ✓ Enforce Shelf Life Constraints
            'use_batch_tracking': True,           # ✓ Enable Batch Tracking
            'max_routes_per_destination': 5,      # Default
            'mip_gap': 0.01,                      # 1% MIP Gap Tolerance
            'time_limit_seconds': 120,            # 2 minutes (expect <30s)
            'solver_name': 'cbc',                 # Default solver
            'start_date': planning_start_date,    # Planning horizon start
            'end_date': planning_end_date,        # Planning horizon end (4 weeks)
        }
    
        print("\n" + "="*80)
        print("OPTIMIZATION SETTINGS")
        print("="*80)
        for key, value in settings.items():
            print(f"{key}: {value}")
    
        # Create optimization model (matches UI Planning Tab)
        print("\n" + "="*80)
        print("MODEL CREATION")
        print("="*80)
    
        model_start = time.time()
    
        model = IntegratedProductionDistributionModel(
            forecast=forecast,
            labor_calendar=labor_calendar,
            manufacturing_site=manufacturing_site,
            cost_structure=cost_structure,
            locations=locations,
            routes=routes,
            truck_schedules=truck_schedules,
            max_routes_per_destination=settings['max_routes_per_destination'],
            allow_shortages=settings['allow_shortages'],
            enforce_shelf_life=settings['enforce_shelf_life'],
            initial_inventory=initial_inventory.to_optimization_dict() if initial_inventory else None,
            inventory_snapshot_date=inventory_snapshot_date,
            start_date=settings['start_date'],
            end_date=settings['end_date'],
            use_batch_tracking=settings['use_batch_tracking'],
        )
    
        model_build_time = time.time() - model_start
    
        # Model statistics
        horizon_days = len(model.production_dates)
        horizon_weeks = horizon_days / 7.0
    
        print(f"✓ Model built in {model_build_time:.2f}s")
        print(f"  Routes enumerated: {len(model.enumerated_routes)}")
        print(f"  Planning horizon: {horizon_days} days ({horizon_weeks:.1f} weeks)")
        print(f"  Date range: {model.start_date} to {model.end_date}")
        print(f"  Batch tracking: {'ENABLED' if settings['use_batch_tracking'] else 'DISABLED'}")
    
        # Validate planning horizon
        assert model.start_date == planning_start_date, \
            f"Model start date {model.start_date} doesn't match expected {planning_start_date}"
        assert model.end_date == planning_end_date, \
            f"Model end date {model.end_date} doesn't match expected {planning_end_date}"
    
        # Solve optimization (matches UI "Solve Optimization Model" button)
        print("\n" + "="*80)
        print("SOLVING OPTIMIZATION")
        print("="*80)
    
        solve_start = time.time()
    
        result = model.solve(
            solver_name=settings['solver_name'],
            time_limit_seconds=settings['time_limit_seconds'],
            mip_gap=settings['mip_gap'],
            use_aggressive_heuristics=True,  # Enable CBC performance features
            tee=False,  # Don't show solver output in test
        )
    
        solve_time = time.time() - solve_start
    
        print(f"✓ Solved in {solve_time:.2f}s")
    
        # Check solution status (but continue to show diagnostics even if slow)
        if not (result.is_optimal() or result.is_feasible()):
            pytest.fail(f"Solution not optimal/feasible: {result.termination_condition}")
    
        # Print solution summary
        print("\n" + "="*80)
        print("SOLUTION SUMMARY")
        print("="*80)
        print(f"Status: {result.termination_condition}")
        print(f"Objective value: ${result.objective_value:,.2f}")
        print(f"Solve time: {result.solve_time_seconds:.2f}s")
        if result.gap is not None:
            print(f"Gap: {result.gap * 100:.2f}%")
    
        # Extract solution details
        solution = model.get_solution()
        assert solution is not None, "Solution should not be None"
    
        # Cost breakdown
        print("\n" + "="*80)
        print("COST BREAKDOWN")
        print("="*80)
        print(f"Labor cost:     ${solution.get('total_labor_cost', 0):>12,.2f}")
        print(f"Production cost: ${solution.get('total_production_cost', 0):>12,.2f}")
        print(f"Transport cost: ${solution.get('total_transport_cost', 0):>12,.2f}")
        print(f"Inventory cost: ${solution.get('total_inventory_cost', 0):>12,.2f}")
        print(f"Shortage cost:  ${solution.get('total_shortage_cost', 0):>12,.2f}")
        print(f"{'-'*40}")
        print(f"TOTAL:          ${solution.get('total_labor_cost', 0) + solution.get('total_production_cost', 0) + solution.get('total_transport_cost', 0) + solution.get('total_inventory_cost', 0) + solution.get('total_shortage_cost', 0):>12,.2f}")
    
        # Production summary - calculate from production_by_date_product
        production_by_date_product = solution.get('production_by_date_product', {})
        total_production = sum(production_by_date_product.values())
        num_batches = len(solution.get('production_batches', []))
        total_labor_hours = sum(solution.get('labor_hours_by_date', {}).values())
    
        print("\n" + "="*80)
        print("PRODUCTION SUMMARY")
        print("="*80)
        print(f"Total production: {total_production:,.0f} units")
        print(f"Production batches: {num_batches}")
        print(f"Total labor hours: {total_labor_hours:.1f}h")
        if num_batches > 0 and total_production > 0:
            print(f"Average batch size: {total_production / num_batches:,.0f} units")
    
        # Shipment summary
        shipments = model.get_shipment_plan()
        if shipments:
            print("\n" + "="*80)
            print("DISTRIBUTION SUMMARY")
            print("="*80)
            print(f"Shipments created: {len(shipments)}")
            print(f"Total shipped: {sum(s.quantity for s in shipments):,.0f} units")
    
            # Count unique destinations
            destinations = set(s.destination_id for s in shipments)
            print(f"Destinations served: {len(destinations)}")
    
        # Demand satisfaction
        total_shortage_units = solution.get('total_shortage_units', 0)
        total_demand = sum(e.quantity for e in forecast.entries)
    
        # Filter demand to planning horizon
        demand_in_horizon = sum(
            e.quantity for e in forecast.entries
            if planning_start_date <= e.forecast_date <= planning_end_date
        )
    
        fill_rate = 100 * (1 - total_shortage_units / demand_in_horizon) if demand_in_horizon > 0 else 100
    
        print("\n" + "="*80)
        print("DEMAND SATISFACTION")
        print("="*80)
        print(f"Total demand (forecast): {total_demand:,.0f} units")
        print(f"Demand in horizon: {demand_in_horizon:,.0f} units")
        print(f"Shortage: {total_shortage_units:,.0f} units")
        print(f"Fill rate: {fill_rate:.1f}%")
    
        # ASSERT: Reasonable fill rate (should be very high with 4-week horizon and initial inventory)
        assert fill_rate >= 95.0, \
            f"Fill rate {fill_rate:.1f}% is below expected 95% threshold"
    
        # Validate initial inventory was used
        if initial_inventory:
            print("\n" + "="*80)
            print("INITIAL INVENTORY VALIDATION")
            print("="*80)
    
            # Check cohort inventory includes initial inventory dates
            if 'cohort_inventory' in solution:
                cohort_inv = solution['cohort_inventory']
    
                # Extract production dates from cohort keys: (loc, prod, prod_date, curr_date, state)
                prod_dates_in_cohorts = set()
                for key in cohort_inv.keys():
                    if len(key) >= 3:
                        prod_date = key[2]
                        prod_dates_in_cohorts.add(prod_date)
    
                # Check if inventory snapshot date appears as production date (initial inventory)
                has_initial_inventory_cohorts = inventory_snapshot_date in prod_dates_in_cohorts
    
                print(f"Inventory snapshot date in cohorts: {has_initial_inventory_cohorts}")
                print(f"Production dates in cohorts: {len(prod_dates_in_cohorts)}")
                print(f"Date range: {min(prod_dates_in_cohorts)} to {max(prod_dates_in_cohorts)}")
    
                # ASSERT: Initial inventory cohorts should exist
                assert has_initial_inventory_cohorts, \
                    "Initial inventory cohorts not found in solution"
            else:
                print("⚠ Cohort inventory not available in solution (batch tracking may be disabled)")
    
        # Performance summary
        print("\n" + "="*80)
        print("PERFORMANCE SUMMARY")
        print("="*80)
        print(f"Model build time: {model_build_time:.2f}s")
        print(f"Solve time: {solve_time:.2f}s")
        print(f"Total time: {model_build_time + solve_time:.2f}s")
        print(f"Status: {'✓ PASSED' if solve_time < 30 else '✗ SLOW'}")
    
        # Deferred assertions (run after all diagnostics)
        deferred_assertions = []
    
        if not (result.is_optimal() or result.is_feasible()):
            deferred_assertions.append(f"Solution not optimal/feasible: {result.termination_condition}")
    
        if solve_time >= 30:
            deferred_assertions.append(f"⚠ Solve time {solve_time:.2f}s exceeds 30s threshold (performance regression)")
    
        if fill_rate < 95.0:
            deferred_assertions.append(f"Fill rate {fill_rate:.1f}% is below 95% threshold")
    
        if total_production <= 0:
            deferred_assertions.append(f"No production found: total_production={total_production}, batches={num_batches}")
    
        if num_batches <= 0:
            deferred_assertions.append(f"Expected production batches but got {num_batches}")
    
        # Check inventory on FIRST and FINAL day of planning horizon
        print("\n" + "="*80)
        print("FIRST & FINAL DAY INVENTORY CHECK")
        print("="*80)
    
        # Get cohort inventory for final date
        if 'cohort_inventory' in solution:
            cohort_inv = solution['cohort_inventory']
    
            # Calculate total inventory on FIRST day (model.start_date)
            first_day_inventory = 0.0
            first_day_by_location = {}
    
            for (loc, prod, prod_date, curr_date, state), qty in cohort_inv.items():
                if curr_date == model.start_date and qty > 0.01:
                    first_day_inventory += qty
                    if loc not in first_day_by_location:
                        first_day_by_location[loc] = 0.0
                    first_day_by_location[loc] += qty
    
            print(f"FIRST day ({model.start_date}) inventory: {first_day_inventory:,.0f} units")
            if first_day_by_location:
                print("  By location:")
                for loc, qty in sorted(first_day_by_location.items(), key=lambda x: x[1], reverse=True)[:5]:
                    if qty > 0.01:
                        print(f"    {loc}: {qty:,.0f} units")
    
            # Calculate total inventory on final day (model.end_date)
            final_day_inventory = 0.0
            final_day_by_location = {}
    
            for (loc, prod, prod_date, curr_date, state), qty in cohort_inv.items():
                if curr_date == model.end_date and qty > 0.01:
                    final_day_inventory += qty
                    if loc not in final_day_by_location:
                        final_day_by_location[loc] = 0.0
                    final_day_by_location[loc] += qty
    
            print(f"Final planning date: {model.end_date}")
            print(f"Total inventory on final day: {final_day_inventory:,.0f} units")
    
            if final_day_by_location:
                print("\nInventory by location on final day:")
                for loc, qty in sorted(final_day_by_location.items(), key=lambda x: x[1], reverse=True):
                    if qty > 0.01:
                        print(f"  {loc}: {qty:,.0f} units")
    
            # Check shipments that deliver AFTER the planning horizon
            shipments = model.get_shipment_plan() or []
            shipments_after_horizon = [s for s in shipments if s.delivery_date > model.end_date]
            total_in_transit_beyond = sum(s.quantity for s in shipments_after_horizon)
    
            if shipments_after_horizon:
                print(f"\n⚠ CRITICAL: Shipments delivering AFTER planning horizon:")
                print(f"  Count: {len(shipments_after_horizon)}")
                print(f"  Total quantity: {total_in_transit_beyond:,.0f} units")
                print(f"  Delivery dates: {min(s.delivery_date for s in shipments_after_horizon)} to {max(s.delivery_date for s in shipments_after_horizon)}")
    
                # These shipments are in-transit on the final day
                print(f"\n  This explains why inventory appears on final day - it's in-transit!")
    
            # Check if there's demand after the planning horizon
            demand_after_horizon = sum(
                e.quantity for e in forecast.entries
                if e.forecast_date > model.end_date
            )
    
            print(f"\nDemand after planning horizon ({model.end_date}): {demand_after_horizon:,.0f} units")
            print(f"Model's knowledge of future demand: NONE (only sees {len(model.demand)} demand entries within horizon)")
    
            # Calculate actual material balance
            demand_in_horizon = sum(
                e.quantity for e in forecast.entries
                if model.start_date <= e.forecast_date <= model.end_date
            )
    
            print(f"\nMaterial Balance Check:")
            print(f"  Production: {total_production:,.0f} units")
            print(f"  Demand in horizon: {demand_in_horizon:,.0f} units")
            print(f"  Shortage (unmet): {total_shortage_units:,.0f} units")
            print(f"  Satisfied demand: {demand_in_horizon - total_shortage_units:,.0f} units")
            print(f"  Final day inventory: {final_day_inventory:,.0f} units")
            print(f"  Shipments after horizon: {total_in_transit_beyond:,.0f} units")
            print(f"  Total outflow (satisfied + final inv): {(demand_in_horizon - total_shortage_units) + final_day_inventory:,.0f} units")
    
            # Check actual demand consumption from cohort tracking
            cohort_demand_consumption = solution.get('cohort_demand_consumption', {})
            actual_consumption_from_cohorts = sum(cohort_demand_consumption.values())
    
            print(f"\n  Demand satisfaction validation:")
            print(f"    Method 1 (Forecast - Shortage): {demand_in_horizon - total_shortage_units:,.0f} units")
            print(f"    Method 2 (Cohort Consumption): {actual_consumption_from_cohorts:,.0f} units")
    
            # Recalculate material balance with actual cohort consumption
            total_outflow_cohort = actual_consumption_from_cohorts + final_day_inventory + total_in_transit_beyond
            balance_diff_cohort = total_production - total_outflow_cohort
    
            print(f"\n  Material balance (using cohort consumption):")
            print(f"    Production: {total_production:,.0f}")
            print(f"    Consumption + Final Inv: {total_outflow_cohort:,.0f}")
            print(f"    Balance: {balance_diff_cohort:+,.0f} units")
    
            # Check if production equals outflow
            total_outflow = (demand_in_horizon - total_shortage_units) + final_day_inventory + total_in_transit_beyond
            balance_diff = total_production - total_outflow
    
            if abs(balance_diff) > 100:  # Threshold for reporting imbalance
                print(f"\n⚠ MATERIAL BALANCE ISSUE (Method 1 - Forecast-based):")
                print(f"  Production: {total_production:,.0f}")
                print(f"  Total outflow: {total_outflow:,.0f}")
                print(f"  Difference: {balance_diff:,.0f} units")
    
                if abs(balance_diff_cohort) < 100:
                    print(f"\n✓ BUT Material balance OK when using cohort consumption!")
                    print(f"  Issue is in how 'satisfied demand' is calculated from forecast-shortage")
                    print(f"  Actual consumption (from cohorts): {actual_consumption_from_cohorts:,.0f}")
                    print(f"  Calculated (forecast - shortage): {demand_in_horizon - total_shortage_units:,.0f}")
                    print(f"  Difference: {(demand_in_horizon - total_shortage_units) - actual_consumption_from_cohorts:,.0f} units (accounting error)")
                else:
                    print(f"\n❌ Material balance ALSO wrong with cohort method!")
                    print(f"  This indicates a real flow conservation bug in the model")
    
            if final_day_inventory > 0.01:
                if total_in_transit_beyond > 0:
                    print(f"\n✓ End inventory is likely in-transit shipments beyond horizon")
                elif demand_after_horizon > 0:
                    print(f"\n⚠ Model doesn't see future demand, yet holds {final_day_inventory:,.0f} units")
                    print(f"  Reason: No end-of-horizon inventory penalty in objective function")
                else:
                    print(f"\n⚠ Final day inventory ({final_day_inventory:,.0f} units) appears to be excess")
        else:
            print("⚠ Cohort inventory not available - cannot check final day inventory")
    
        print("\n" + "="*80)
        print("TEST PASSED ✓")
        print("="*80)
    
        # Run deferred assertions at the end (after all diagnostics printed)
        if deferred_assertions:
            print("\n" + "="*80)
            print("⚠ ASSERTION FAILURES")
            print("="*80)
            for assertion in deferred_assertions:
                print(f"  • {assertion}")
>           pytest.fail("\n".join(deferred_assertions))
E           Failed: ⚠ Solve time 39.32s exceeds 30s threshold (performance regression)

tests/test_integration_ui_workflow.py:585: Failed
=============================== warnings summary ===============================
venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:323
venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:323
venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:323
venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:323
  /home/sverzijl/planning_latest/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

tests/test_integration_ui_workflow.py::test_ui_workflow_4_weeks_with_initial_inventory
  /home/sverzijl/planning_latest/src/optimization/integrated_model.py:790: UserWarning: 
  Planning horizon may be insufficient:
    Current start: 2025-10-07
    Required start: 2025-10-03 (4 days earlier)
    Max transit time: 3.5 days
    Early demand (on 2025-10-07) cannot be satisfied.
    Solution: Extend planning horizon or accept reduced demand satisfaction.
    warnings.warn(

tests/test_integration_ui_workflow.py::test_ui_workflow_4_weeks_with_initial_inventory
  /home/sverzijl/planning_latest/src/optimization/integrated_model.py:802: UserWarning: 
  Planning horizon end date may be insufficient:
    Current end: 2025-11-04
    Required end: 2026-12-31 (422 days later)
    Late demand (on 2026-12-31) will be filtered out.
    Solution: Extend planning horizon end date to include all demand.
    warnings.warn(

tests/test_integration_ui_workflow.py::test_ui_workflow_4_weeks_with_initial_inventory
  /home/sverzijl/planning_latest/src/optimization/integrated_model.py:839: UserWarning: Re-filtered 16880 demand entries after planning horizon adjustment. Adjusted horizon: [2025-10-07, 2025-11-04]
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_integration_ui_workflow.py::test_ui_workflow_4_weeks_with_initial_inventory
======================== 1 failed, 7 warnings in 47.29s ========================
