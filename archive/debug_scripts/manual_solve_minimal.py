#!/usr/bin/env python3
"""Manual constraint analysis of minimal case.

Traces through the logic to find what forces production=2000 when demand=1000.
"""

print("="*80)
print("MANUAL CONSTRAINT ANALYSIS - Minimal Case")
print("="*80)
print()
print("Setup:")
print("  - Demand on day 7: 1,000 units at BR1")
print("  - Route: MFG → BR1 (1-day transit)")
print("  - Production cost: $5/unit")
print("  - Shortage penalty: $10,000/unit")
print()
print("Expected Optimal Solution:")
print("  - Produce 1,000 units on day 6 at MFG")
print("  - Ship 1,000 units (depart day 6, arrive day 7)")
print("  - BR1 inventory day 7 before demand: 1,000 units")
print("  - demand_from_cohort[BR1, PROD1, day_6, day_7] = 1,000")
print("  - BR1 inventory day 7 after demand: 0 units")
print("  - Total cost: $5,000 production + $1,000 transport + labor")
print()
print("Actual Solution (from test):")
print("  - Produce 2,000 units on day 5 at MFG")
print("  - ??? What happened to the extra 1,000 ???")
print()
print("="*80)
print("CONSTRAINT TRACE")
print("="*80)
print()

print("[1] Demand Satisfaction Constraint")
print("   Line 359-368 of .lp file:")
print("   sum(demand_from_cohort[..., day_7]) + shortage = 1000")
print()
print("   Valid cohorts that can satisfy day 7 demand:")
print("   - BR1_PROD1_2025_01_07_2025_01_07 (produced day 7, consumed day 7)")
print("   - BR1_PROD1_2025_01_06_2025_01_07 (produced day 6, consumed day 7)")
print("   - BR1_PROD1_2025_01_05_2025_01_07 (produced day 5, consumed day 7)")
print("   - BR1_PROD1_2025_01_04_2025_01_07 (produced day 4, consumed day 7)")
print("   - BR1_PROD1_2025_01_03_2025_01_07 (produced day 3, consumed day 7)")
print("   - BR1_PROD1_2025_01_02_2025_01_07 (produced day 2, consumed day 7)")
print("   - BR1_PROD1_2025_01_01_2025_01_07 (produced day 1, consumed day 7)")
print()
print("   Model can satisfy from ANY of these cohorts (all within 14-day shelf life)")
print()

print("[2] Demand-Inventory Linking Constraints")
print("   Lines 370-403 of .lp file:")
print("   For each cohort: demand_from_cohort <= inventory_cohort")
print()
print("   Example (line 390-393):")
print("   demand_from_cohort[BR1, day_5, day_7] <= inventory[BR1, day_5, day_7]")
print()
print("   This ensures demand can only be satisfied from available inventory")
print()

print("[3] Inventory Balance - KEY ANALYSIS")
print()
print("   For BR1 cohort produced day 5, consumed day 7:")
print("   Line 274-279 shows:")
print()
print("   c_e_inventory_balance_con(BR1_PROD1_2025_01_05_2025_01_07_ambient):")
print("   -shipment[MFG→BR1, day_5, deliver_day_7]")
print("   -inventory[BR1, day_5, day_6]")
print("   +inventory[BR1, day_5, day_7]")
print("   +demand_from_cohort[BR1, day_5, day_7]")
print("   = 0")
print()
print("   Rearranging:")
print("   inventory[BR1, day_5, day_7] = inventory[BR1, day_5, day_6] + shipment - demand")
print()
print("   If demand=1000 and shipment=1000:")
print("   inventory[day_7] = inv[day_6] + 1000 - 1000 = inv[day_6]")
print()
print("   **But wait!** If inv[day_6]=0 (no inventory before arrival):")
print("   inventory[day_7] = 0 + 1000 - 1000 = 0  ← CORRECT!")
print()
print("   So where does the extra 1000 come from?")
print()

print("[4] Hypothesis: Multiple Cohorts Satisfying Demand")
print()
print("   The linking constraints allow demand to be satisfied from:")
print("   - Cohort day_1: demand_from_cohort[day_1] <= inv[day_1, day_7]")
print("   - Cohort day_2: demand_from_cohort[day_2] <= inv[day_2, day_7]")
print("   - Cohort day_5: demand_from_cohort[day_5] <= inv[day_5, day_7]")
print("   - etc.")
print()
print("   And demand satisfaction requires:")
print("   sum(all cohorts) = 1000")
print()
print("   Could the model be setting:")
print("   - demand_from_cohort[day_5] = 1000 (satisfies demand)")
print("   - But ALSO producing from day_1/day_2/etc?")
print()
print("   If so, why? There's no benefit (costs money).")
print()

print("[5] Check for Missing Constraint")
print()
print("   The model has:")
print("   ✓ Demand satisfaction: ensures 1000 units allocated")
print("   ✓ Linking: ensures allocation doesn't exceed inventory")
print("   ✓ Balance: ensures inventory flow is conserved")
print("   ✓ Objective: penalizes all production")
print()
print("   Missing:")
print("   ✗ Constraint that says 'if demand=1000, produce exactly 1000'")
print("   ✗ Or 'minimize production' directly")
print()
print("   **The objective minimizes COST, not production volume!**")
print()
print("   If there's any way production can be > 1000 without increasing cost,")
print("   the solver might choose it (degenerate solution).")
print()

print("[6] Check Cost Calculation")
print()
print("   Objective (lines 4-11 of .lp):")
print("   +5.022321428571429 production(MFG_PROD1_2025_01_05)")
print()
print("   Cost = $5.02 (not exactly $5.00)")
print("   Where does 5.022321... come from?")
print()
print("   Source: Lines 1481 in Python code:")
print("   production_cost_per_unit ($5) + labor cost component")
print()
print("   Labor is being included in production cost!")
print("   blended_rate = (25 + 37.5) / 2 = 31.25")
print("   hours_per_unit = 1 / 1400 = 0.000714")
print("   labor_per_unit = 31.25 * 0.000714 = 0.0223")
print("   total = 5.00 + 0.0223 = 5.0223 ✓")
print()
print("   So cost is correctly applied.")
print()

print("="*80)
print("CONCLUSION")
print("="*80)
print()
print("All constraints appear mathematically correct:")
print("  ✓ Signs are correct")
print("  ✓ Demand satisfaction properly structured")
print("  ✓ Inventory balance conserves flow")
print("  ✓ Production cost applied")
print()
print("The 2x production bug must be due to:")
print("  A. Solver degeneracy (multiple optimal solutions, picks wrong one)")
print("  B. Missing tightness in constraints (allows excess without penalty)")
print("  C. Numerical issue in solver")
print("  D. Something subtle in how Pyomo translates the Python constraints")
print()
print("Next step: Extract actual solution values for ALL variables and check")
print("which constraints are binding (slack=0) vs loose (slack>0).")
print()
print("="*80)
