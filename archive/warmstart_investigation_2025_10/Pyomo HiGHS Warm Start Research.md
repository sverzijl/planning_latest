

# **A Comprehensive Guide to Warm-Starting Optimization Models: Theory and Practice with Pyomo and HiGHs**

## **The Principle and Purpose of Warm-Starting in Mathematical Optimization**

In the domain of mathematical optimization, efficiency is paramount. As models grow in scale and complexity, the time required to find an optimal solution can become a significant bottleneck. A powerful technique for accelerating this process is the "warm start," which involves providing a solver with information from a previous or related optimization run. This foundational section demystifies the concept of warm-starting, establishing its theoretical underpinnings and clarifying the distinct mechanisms at play across different classes of optimization problems.

### **Defining the Warm Start: From Initial Guess to Algorithmic State**

At its core, a warm start provides a solver with a head start, leveraging prior knowledge to reduce the search space or the number of iterations required to converge to an optimal solution. This prior knowledge can originate from various sources, including the solution to a simplified version of the problem, the optimal point from a previous time step in a dynamic or sequential model, or a high-quality feasible solution generated by a domain-specific heuristic.1 In recent years, a modern approach has emerged where machine learning models are trained to predict effective warm starts based on problem parameters, further enhancing efficiency.

It is critical to distinguish between providing *initial values* and defining *initial conditions*. An initial value is merely a guess at the optimal solution; the solver is free to use it as a starting point or discard it entirely if it proves unhelpful. An initial condition, by contrast, is a fixed aspect of the problem definition. In a dynamic model, this would be a state that is not a guess but a requirement, typically implemented as a fixed variable or an equality constraint (e.g., m.x.fix(100)). Mistaking one for the other is a common source of modeling errors.

The term "warm start" itself is often used imprecisely, yet its meaning and mechanism differ fundamentally depending on the type of problem and the algorithm being used. For Linear Programs (LPs), a warm start can involve transferring the entire algorithmic state, representing a very "hot" continuation of the solution process. For Mixed-Integer Programs (MIPs), it typically involves providing a heuristic seed—a feasible solution—to guide the search. This distinction is not merely academic; it has profound implications for how warm starts are implemented and the performance benefits they can deliver.

### **Mechanisms in Linear Programming (LP): The Power of the Basis**

For LPs solved via the simplex method, the concept of a warm start transcends a simple vector of variable values. The most valuable piece of information is the *basis*—the set of basic and non-basic variables that defines an optimal vertex in the feasible region.4

When solving a sequence of slightly modified LPs, providing the optimal basis from the previous problem allows the simplex algorithm to achieve remarkable efficiency gains. The solver can often bypass "Phase 1" (the search for an initial feasible solution) entirely and, starting from the provided feasible basis, may require only a handful of "Phase 2" iterations to pivot to the new optimal vertex.5 This ability is not just beneficial for standalone LPs; it forms the bedrock of modern MIP solvers. The branch-and-cut algorithm, which is the standard for solving MIPs, relies on solving thousands of closely related LP subproblems (relaxations). The ability to "hot start" each of these subproblems using the basis from its parent node in the search tree is critical to the overall performance of the MIP solver.5 This symbiotic relationship highlights a second-order dependency: the efficiency of a MIP solver is directly linked to the warm-start capabilities of its underlying LP solver. This is a primary reason why the dual simplex algorithm is often preferred within branch-and-cut, as modifications like adding bounds to variables frequently preserve dual feasibility, making re-optimization from a warm start exceptionally fast.6

In contrast, warm-starting interior-point methods is known to be "much less efficient".7 These algorithms traverse the interior of the feasible polytope and do not naturally terminate at a vertex or produce a basis. While a procedure known as "crossover" can be used to convert an interior-point solution into a basic solution, it adds computational overhead and diminishes the primary benefit of a direct basis warm start.8

### **Strategies in Mixed-Integer Programming (MIP): Seeding the Branch-and-Cut Tree**

For MIPs, the warm start strategy shifts from providing an algorithmic state to providing a high-quality feasible solution, often called a "MIP start".2 This initial solution, known as the *incumbent*, serves as an initial upper bound on the optimal objective value (for a minimization problem).

The primary benefit of an early incumbent is its power to prune the branch-and-cut search tree. As the algorithm explores nodes in the tree, it solves an LP relaxation at each node to get a lower bound on the best possible integer solution in that part of the search space. If the lower bound at a given node is worse than the objective value of the known incumbent solution, that node and its entire descendant subtree can be "fathomed" or pruned from the search. A high-quality warm start provides a tight initial upper bound, enabling the solver to prune vast sections of the tree early on, dramatically reducing the number of nodes that must be explored.2

Furthermore, having an incumbent solution from the outset enables the use of powerful improvement heuristics that require a feasible starting point. Techniques like Relaxation Induced Neighborhood Search (RINS) or solution polishing work by exploring the neighborhood of a known integer solution to find better ones. A warm start gives these heuristics a fertile starting ground immediately, often leading to rapid improvements in the incumbent solution.5

### **Anticipated Performance Impact: A Cost-Benefit Analysis**

The decision to implement a warm start is a cost-benefit analysis. It is most beneficial in scenarios involving the resolution of sequences of similar problems, such as in Model Predictive Control (MPC), rolling horizon planning, or decomposition algorithms like Benders decomposition.5 It is also highly effective for problems where finding an initial feasible solution is computationally difficult, or when a domain-specific heuristic can generate a high-quality starting point more cheaply than the solver's own methods.5 For challenging MIPs, a good warm start can reduce solution times from hours to minutes, or even make the difference between finding a proven optimal solution and finding none at all within a given time limit.5

## **Providing Initial Solutions within the Pyomo Framework**

Transitioning from theory to practice, the Pyomo modeling language offers several mechanisms for providing initial solutions to solvers. However, the effectiveness and even the syntax of these mechanisms depend critically on the specific solver interface being used. This section details the methods for initializing variables in Pyomo and provides a critical analysis of its different communication protocols, highlighting a common source of user confusion.

### **Methods for Initializing Pyomo Variables**

Pyomo provides two primary ways to set the initial values of decision variables before a solve is initiated.

* **The initialize Keyword:** The most direct method is to use the initialize argument during the declaration of a Var component. This approach is flexible, accepting a single value for scalar variables or all elements of an indexed variable, a dictionary mapping indices to specific values, or a function that returns the initial value(s).13  
* **Direct .value Assignment:** Alternatively, one can assign a value to the .value attribute of a variable object at any point after its declaration but before the call to the solve() method.13 This is particularly useful when the initial values are derived from calculations or are the result of a previous solve.

A crucial distinction exists for users of Pyomo's AbstractModel. In this paradigm, the model structure is defined separately from the data. Therefore, initial value assignments must be performed on the concrete instance object returned by the model.create\_instance() method, not on the abstract model definition itself.13

### **The solve() Method's warmstart=True Argument: A Deceptive Simplicity**

The canonical method for signaling the intent to perform a warm start in Pyomo is to pass the warmstart=True argument to the solver's solve() method: results \= opt.solve(instance, warmstart=True).1

However, this apparent simplicity is misleading. This argument should be understood as a *request* to the Pyomo solver interface, not a command to the solver itself. Its behavior is not uniform. Some interfaces do not recognize the keyword at all, and even when recognized, the solver retains the right to reject the provided start if it is determined to be infeasible or of poor quality.21

### **Navigating Pyomo's Solver Interfaces: A Critical Analysis**

The most significant practical challenge for users implementing warm starts in Pyomo is the inconsistent behavior across its different solver interfaces. This disparity is not arbitrary but is a direct consequence of the underlying communication protocol Pyomo uses to interact with the solver executable. A user's choice of solver string (e.g., 'gurobi\_direct' vs. 'gurobi\_ampl') is not merely a name but a fundamental selection of a communication method with profound implications for feature support.

* **LP/MPS/Python Interfaces:** For interfaces that communicate with solvers like CBC, or use direct Python bindings for Gurobi or CPLEX, the warmstart=True argument is generally required. When this flag is used, Pyomo generates an auxiliary file (e.g., a .mst or .soln file) containing the initial variable values, which is passed to the solver alongside the main problem file.20 The standard LP and MPS file formats do not have a built-in standard for specifying an initial solution, necessitating this two-file approach.  
* **NL-file Interface:** This interface, which leverages the AMPL Solver Library (ASL) and is invoked for solvers like Ipopt or when using an \_ampl suffix (e.g., gurobi\_ampl), behaves fundamentally differently. The .nl file format has a standardized way to include initial values for variables. Consequently, Pyomo *always* writes the current .value of all variables into the .nl file it generates.13 The warmstart=True keyword is therefore redundant, is not accepted by this interface, and will raise an error if used.20 It is then entirely up to the ASL-compliant solver to decide how to interpret and use these initial values.  
* **The APPSI Interface:** The Auto-Persistent Pyomo Solver Interfaces (APPSI) represent a modern paradigm for solver interaction.24 Unlike the "fire-and-forget" approach of generating files and calling an executable, APPSI maintains a persistent, stateful connection to the solver instance in memory. This shift is a game-changer for warm-starting. Instead of repeatedly generating files, a user can modify the model and re-solve within the same solver session, allowing the solver to leverage its internal state and sophisticated hot-start capabilities automatically. This is the most natural and efficient way to perform sequential optimizations and aligns perfectly with the design philosophy of modern solvers like HiGHs.27

The following table consolidates this information into an actionable reference.

| Pyomo Solver Interface | solve() Argument | Mechanism for Passing Initial Values | Supporting Sources |
| :---- | :---- | :---- | :---- |
| LP/MPS/Python (e.g., SolverFactory('cbc')) | warmstart=True | Generates an auxiliary file (e.g., MST, soln) or uses a direct API call. | 19 |
| NL-file (e.g., SolverFactory('gurobi\_ampl')) | warmstart keyword is **not accepted**. | Initial values are automatically written into the .nl file. | 13 |
| APPSI (e.g., appsi.solvers.Highs()) | Controlled via solver.config and solver-specific options. | Direct, persistent communication with the solver instance. | 24 |

## **Leveraging the HiGHs Solver's "Hot Start" Capabilities**

The HiGHs (High Performance Optimization Software) solver is a powerful, open-source package for linear programming (LP), mixed-integer programming (MIP), and quadratic programming (QP) developed by the optimization research group at the University of Edinburgh.32 It features a sophisticated set of "hot start" capabilities that are best utilized through a persistent solver interface.

### **HiGHs Architecture and Solver Support**

A standout feature of HiGHs is its design philosophy, which centers on a persistent solver object. The most efficient way to use HiGHs for sequential optimization is not to create, solve, and destroy the solver for each problem, but to create a single solver instance, pass a model, solve it, modify the model *in place*, and then re-solve.27 When this pattern is followed, HiGHs automatically performs a "hot start," invisibly reusing as much information as possible from the previous solve, such as the basis factorization. This approach, which aligns perfectly with Pyomo's APPSI interface, unlocks maximum performance by minimizing redundant computations.

As with other solvers, the effectiveness of a warm start in HiGHs is algorithm-dependent. The benefits are most pronounced for its high-performance primal and dual simplex solvers.7 While HiGHs supports MIP warm starts by accepting an initial feasible solution, its documentation indicates that warm-starting its active-set QP solver is not a primary development focus at this time.28

### **Advanced Control: setSolution and setBasis**

Beyond its automatic hot-start capabilities, HiGHs provides explicit methods for users to supply starting information. This reveals a clear hierarchy in the quality of warm-start data for LPs: a primal solution is good, a basis is better, and a basis with its factorization (retained internally during a hot start) is best.

* **setSolution:** This method allows a user to provide a complete or partial vector of primal variable values (a HighsSolution object) to the solver before the optimization begins.36 This is the standard mechanism for providing a MIP start. For an LP, HiGHs will attempt to construct a corresponding basis from the provided solution.  
* **setBasis:** This is a more powerful and direct method for warm-starting LPs. It allows the user to provide a HighsBasis object, which specifies the status (kLower, kUpper, kBasic, etc.) for each variable and constraint, directly informing the simplex algorithm of the initial basis.36 HiGHs is robust in this regard; the provided basis does not need to be complete or perfectly valid, as the solver will attempt to repair and complete it before starting the simplex iterations.36

### **HiGHs' Response to Initial Solutions**

For MIP problems, HiGHs' handling of user-provided solutions is sophisticated. If a complete and feasible MIP start is given via setSolution, it is immediately used as the incumbent, providing an initial primal bound to accelerate the branch-and-cut process.36

The solver's behavior with partial or infeasible starts is evolving. Current versions of HiGHs can accept a partial assignment of the discrete variables. The solver will then attempt to find a feasible completion by solving a sub-MIP where the user-provided discrete variables are fixed.36 The computational effort HiGHs dedicates to this completion process can be controlled via the mip\_max\_start\_nodes option.8 If the provided partial solution cannot be completed into a feasible solution, or if a provided full solution is infeasible, the start is discarded, and the solver proceeds with a cold start.39

### **Key Solver Options for Warm-Starting (highs\_options)**

When using HiGHs through Pyomo, several solver-specific options, passed via a dictionary, are crucial for controlling warm-start behavior:

* solver: To maximize the benefit of a basis warm start for an LP, it is essential to ensure the simplex method is used. This can be specified with solver \= 'simplex'.8  
* presolve: An important interaction exists with the presolver. When HiGHs is given a valid basis for an LP, it will automatically skip the presolve step and proceed directly to the simplex algorithm, starting from the provided basis. This is typically the most efficient path for re-solving a slightly modified problem.36  
* mip\_max\_start\_nodes: As mentioned, this integer value controls the number of branch-and-bound nodes HiGHs will explore in its attempt to find a feasible completion for a partial MIP start.8  
* alg:start / alg:basis: When using an AMPL-based interface to HiGHs, these options provide another layer of control over whether and how incoming primal values and basis information are used.41

## **Implementing and Verifying Warm Starts with Pyomo and HiGHs**

The practical implementation of a warm start is a two-step process: coding the logic to provide the initial solution and, crucially, verifying that the solver successfully received and utilized that information. The most common pitfall is assuming a warm start "worked" simply because the code executed without error. The solver's log file, made visible with the tee=True argument, is the primary tool for this essential verification step.

### **Standard Interface Implementation**

This approach uses the standard SolverFactory and is suitable for simpler, single-solve problems.

#### **Step-by-Step Code Example (MIP)**

The following example demonstrates the process for a MIP problem using the standard Pyomo interface.

1. **Prerequisites:** Ensure Pyomo and the HiGHs Python wrapper, highspy, are installed in the environment.42  
2. **Model and Solver Setup:** Import necessary components and build a Pyomo ConcreteModel. Instantiate the HiGHs solver using SolverFactory.  
   Python  
   import pyomo.environ as pyo

   \# 1\. Build a simple MIP model  
   model \= pyo.ConcreteModel()  
   model.x \= pyo.Var(, domain=pyo.Binary)  
   model.y \= pyo.Var(domain=pyo.NonNegativeReals)  
   model.obj \= pyo.Objective(expr=pyo.summation(model.x) \+ model.y, sense=pyo.minimize)  
   model.c1 \= pyo.Constraint(expr=5\*model.x \+ 3\*model.x \+ model.y \>= 4)  
   model.c2 \= pyo.Constraint(expr=model.x \+ 6\*model.x \+ 2\*model.x \+ 2\*model.y \>= 6)

   \# 2\. Set initial values for a warm start  
   \# This could be from a heuristic or a previous solve  
   model.x.value \= 0  
   model.x.value \= 1  
   model.x.value \= 0  
   model.y.value \= 1.0

   \# 3\. Instantiate the solver  
   solver \= pyo.SolverFactory('highs')

   \# 4\. Solve with warmstart=True and tee=True for verification  
   results \= solver.solve(model, warmstart=True, tee=True)

   \# 5\. Print results  
   model.display()

3. **Analyzing the Solver Log:** The tee=True argument is essential for verification.20 In the HiGHs output, a successful MIP warm start may be indicated by an early message stating that a feasible integer solution was found and is being used as the initial incumbent. The log would show a good "Primal bound" from the very beginning of the MIP search. Conversely, if the start is rejected (e.g., for being infeasible), the log will show no initial incumbent, and the solver will proceed as if from a cold start, with the primal bound slowly improving as it finds its first feasible solutions.39

### **Advanced Implementation with the APPSI Interface**

For any application involving sequential or iterative solves, the APPSI interface is the preferred method. Its structure aligns with the persistent, stateful architecture of HiGHs, enabling the most efficient hot-start capabilities.

#### **Step-by-Step Code Example (Sequential LPs)**

This example demonstrates how to solve an LP, modify it, and then re-solve it efficiently using the same solver instance.

1. **Prerequisites and Imports:** Import the APPSI Highs solver class.  
   Python  
   import pyomo.environ as pyo  
   from pyomo.contrib.appsi.solvers import Highs

2. **Model and Solver Setup:** Build the initial model and instantiate the persistent solver. Solver-specific options are set via the highs\_options dictionary.  
   Python  
   \# 1\. Build an LP model with a mutable parameter  
   model \= pyo.ConcreteModel()  
   model.p \= pyo.Param(initialize=1, mutable=True)  
   model.x \= pyo.Var(domain=pyo.NonNegativeReals)  
   model.y \= pyo.Var(domain=pyo.NonNegativeReals)  
   model.obj \= pyo.Objective(expr=2\*model.x \+ 3\*model.y, sense=pyo.maximize)  
   model.c1 \= pyo.Constraint(expr=model.x \+ model.y \<= model.p)

   \# 2\. Instantiate the persistent APPSI solver  
   solver \= Highs()  
   solver.highs\_options\['solver'\] \= 'simplex' \# Ensure simplex is used

3. **First (Cold) Solve:** Solve the initial problem.  
   Python  
   print("--- First (Cold) Solve \---")  
   results1 \= solver.solve(model, tee=True)  
   print(f"Objective 1: {pyo.value(model.obj)}")

4. **Modify and Re-Solve (Hot Start):** Modify a parameter in the Pyomo model and call solve() again on the *same solver instance*. APPSI communicates the change to the persistent solver, which performs a hot start automatically.  
   Python  
   print("\\n--- Modifying model and re-solving (Hot Start) \---")  
   model.p \= 2.0 \# Modify the RHS of the constraint  
   results2 \= solver.solve(model, tee=True)  
   print(f"Objective 2: {pyo.value(model.obj)}")

5. **Analyzing the Log for Hot Start:** The HiGHs log output for the two solves will be markedly different. The first "cold" solve will show a certain number of simplex iterations required to find the optimum. The second "hot" solve, benefiting from the retained basis and factorization, should show a significantly lower iteration count, often just one or two, demonstrating a successful and highly efficient hot start. This direct comparison provides undeniable proof of the performance benefit.

## **Performance Tuning and Advanced Strategies**

Implementing a warm start is the first step; optimizing its use requires a deeper understanding of its interaction with the solver's internal strategies. A warm start is not a universally guaranteed performance enhancement but rather a powerful heuristic that, when used judiciously, can yield substantial benefits.

### **The Double-Edged Sword: When a Warm Start Can Hinder Performance**

While often beneficial, providing a MIP start can sometimes be counterproductive. Modern MIP solvers are equipped with a portfolio of powerful primal heuristics designed to quickly find good-quality integer solutions at the root node. By providing a user-defined starting solution, a solver may alter its strategy or disable some of these internal heuristics.19 If the user-provided solution is of mediocre quality, the solver might have found a better one faster on its own. In some documented cases, providing the known optimal solution has even resulted in longer solve times to *prove* optimality compared to a cold start, because it altered the solver's search path in a suboptimal way.45 The quality of the start is paramount; a poor initial guess can mislead the solver's branching decisions or other heuristics.46

### **Best Practices for Generating High-Quality Initial Solutions**

The efficacy of a warm start is directly tied to the quality of the provided solution. Several strategies can be employed to generate effective starting points:

* **Leverage Domain Knowledge:** Problem-specific heuristics are often the most potent source of high-quality solutions.  
* **Solve a Simplified Model:** A common and effective technique is to first solve a relaxed (e.g., continuous relaxation) or simplified version of the problem. The solution can then be rounded or repaired to create a feasible integer starting point for the full, complex model.  
* **Employ a Two-Stage Approach:** For complex MIPs, one can first solve a version of the model where key strategic binary variables are fixed based on a heuristic. This initial solve produces a fully populated, feasible solution for all variables. This complete solution can then be used as a high-integrity warm start for a second solve where all variables are unfixed, allowing the optimizer to improve upon a known good, feasible point.39

### **Application in Iterative Schemes**

Warm starts are most indispensable in iterative algorithms where a sequence of related optimization problems is solved:

* **Model Predictive Control (MPC):** In MPC, an optimization problem is solved at each time step over a future horizon. The optimal solution from time step $t$ is typically an excellent starting point for the problem at time step $t+1$, which is often only slightly different.47  
* **Decomposition Algorithms:** Methods like Benders decomposition and column generation involve iterating between a master problem and one or more subproblems. The ability to hot-start each solve is essential for the overall efficiency of these advanced algorithms.48  
* **Sensitivity Analysis:** When performing sensitivity analysis by systematically changing objective coefficients or resource availabilities (RHS values), hot-starting each subsequent LP solve from the previous optimal basis is the most efficient way to compute the new solution.10

### **Recommendations for Robust Implementation**

To conclude, a set of best practices can ensure that warm starts are implemented robustly and effectively:

1. **Always Verify:** Treat the tee=True argument and the solver log as indispensable tools. Never assume a warm start was used successfully without explicit confirmation from the solver's output.  
2. **Benchmark:** A warm start is a performance heuristic. Its impact should be empirically validated by benchmarking solve times with and without the warm start on a representative set of problem instances.12  
3. **Prefer APPSI for HiGHs:** For any application involving iterative solves with HiGHs, the APPSI interface is strongly recommended. It provides the most direct, transparent, and efficient path to leveraging the solver's native hot-start capabilities, aligning the structure of the user's code with the solver's internal architecture.  
4. **Look to the Future:** The field is evolving towards data-driven optimization. The emergence of techniques that use machine learning to predict high-quality warm starts from problem data points to a future where heuristic generation may become automated, further pushing the boundaries of solver performance.3

#### **Works cited**

1. What Exactly Is A Warm Start? \[duplicate\] \- Operations Research Stack Exchange, accessed October 22, 2025, [https://or.stackexchange.com/questions/2576/what-exactly-is-a-warm-start](https://or.stackexchange.com/questions/2576/what-exactly-is-a-warm-start)  
2. Starting from a solution: MIP starts \- IBM, accessed October 22, 2025, [https://www.ibm.com/docs/en/icos/22.1.0?topic=mip-starting-from-solution-starts](https://www.ibm.com/docs/en/icos/22.1.0?topic=mip-starting-from-solution-starts)  
3. \[2309.07835\] Learning to Warm-Start Fixed-Point Optimization Algorithms \- arXiv, accessed October 22, 2025, [https://arxiv.org/abs/2309.07835](https://arxiv.org/abs/2309.07835)  
4. www.mathworks.com, accessed October 22, 2025, [https://www.mathworks.com/help/optim/ug/optimwarmstart.html\#:\~:text=A%20warm%20start%20object%20maintains,active%20set%20information%20is%20reused.](https://www.mathworks.com/help/optim/ug/optimwarmstart.html#:~:text=A%20warm%20start%20object%20maintains,active%20set%20information%20is%20reused.)  
5. How does a warm start work in LP/MIP? \- Operations Research Stack Exchange, accessed October 22, 2025, [https://or.stackexchange.com/questions/1278/how-does-a-warm-start-work-in-lp-mip](https://or.stackexchange.com/questions/1278/how-does-a-warm-start-work-in-lp-mip)  
6. Learning To Scale Mixed-Integer Programs \- AAAI Publications, accessed October 22, 2025, [https://ojs.aaai.org/index.php/AAAI/article/view/16482/16289](https://ojs.aaai.org/index.php/AAAI/article/view/16482/16289)  
7. linear programming \- Free solver for large LP with warm start and ..., accessed October 22, 2025, [https://or.stackexchange.com/questions/12493/free-solver-for-large-lp-with-warm-start-and-shadow-prices](https://or.stackexchange.com/questions/12493/free-solver-for-large-lp-with-warm-start-and-shadow-prices)  
8. HiGHS \- GAMS, accessed October 22, 2025, [https://www.gams.com/50/docs/S\_HIGHS.html](https://www.gams.com/50/docs/S_HIGHS.html)  
9. Disabling Crossover using HiGHS Solver and Linopy \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/79480779/disabling-crossover-using-highs-solver-and-linopy](https://stackoverflow.com/questions/79480779/disabling-crossover-using-highs-solver-and-linopy)  
10. Warm Starting for Mixed Integer Linear Programs \- Computational Optimization Research At Lehigh, accessed October 22, 2025, [https://coral.ise.lehigh.edu/\~ted/files/talks/INFORMS07.pdf](https://coral.ise.lehigh.edu/~ted/files/talks/INFORMS07.pdf)  
11. Speeding up highsmp \- Support \- AMPL Discourse, accessed October 22, 2025, [https://discuss.ampl.com/t/speeding-up-highsmp/421](https://discuss.ampl.com/t/speeding-up-highsmp/421)  
12. A Distributed Framework for Solving and Benchmarking Security Constrained Unit Commitment With Warm Start | Request PDF \- ResearchGate, accessed October 22, 2025, [https://www.researchgate.net/publication/334687037\_A\_Distributed\_Framework\_for\_Solving\_and\_Benchmarking\_Security\_Constrained\_Unit\_Commitment\_With\_Warm\_Start](https://www.researchgate.net/publication/334687037_A_Distributed_Framework_for_Solving_and_Benchmarking_Security_Constrained_Unit_Commitment_With_Warm_Start)  
13. Set initial primal and dual values for variables pyomo \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/42761370/set-initial-primal-and-dual-values-for-variables-pyomo](https://stackoverflow.com/questions/42761370/set-initial-primal-and-dual-values-for-variables-pyomo)  
14. Pyomo style guide — Companion code for the book "Hands-On Mathematical Optimization with Python", accessed October 22, 2025, [https://mobook.github.io/MO-book/notebooks/appendix/pyomo-style-guide.html](https://mobook.github.io/MO-book/notebooks/appendix/pyomo-style-guide.html)  
15. Sets — Pyomo 6.8.0 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.8.0/pyomo\_modeling\_components/Sets.html](https://pyomo.readthedocs.io/en/6.8.0/pyomo_modeling_components/Sets.html)  
16. initialization \- How to set initial values for decision variables in ..., accessed October 22, 2025, [https://stackoverflow.com/questions/63875978/how-to-set-initial-values-for-decision-variables-in-pyomo-model](https://stackoverflow.com/questions/63875978/how-to-set-initial-values-for-decision-variables-in-pyomo-model)  
17. Ignored initial values of variables \- Google Groups, accessed October 22, 2025, [https://groups.google.com/g/pyomo-forum/c/UmLUjP\_i6ds](https://groups.google.com/g/pyomo-forum/c/UmLUjP_i6ds)  
18. Manipulating Pyomo Models — Pyomo 6.8.1 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.8.1/howto/manipulating.html](https://pyomo.readthedocs.io/en/6.8.1/howto/manipulating.html)  
19. Gurobi warm start heuristics \- Google Groups, accessed October 22, 2025, [https://groups.google.com/g/pyomo-forum/c/f\_dFkHbYxKc](https://groups.google.com/g/pyomo-forum/c/f_dFkHbYxKc)  
20. Solver Recipes — Pyomo 6.9.1 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.9.1/howto/solver\_recipes.html](https://pyomo.readthedocs.io/en/6.9.1/howto/solver_recipes.html)  
21. Initialize and warmstart parameters on Pyomo \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/49288060/initialize-and-warmstart-parameters-on-pyomo](https://stackoverflow.com/questions/49288060/initialize-and-warmstart-parameters-on-pyomo)  
22. Pyomo warm start \- python \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/55250019/pyomo-warm-start](https://stackoverflow.com/questions/55250019/pyomo-warm-start)  
23. Pyomo warmstart does not work with GLPK and CBC, accessed October 22, 2025, [https://or.stackexchange.com/questions/12435/pyomo-warmstart-does-not-work-with-glpk-and-cbc](https://or.stackexchange.com/questions/12435/pyomo-warmstart-does-not-work-with-glpk-and-cbc)  
24. HiGHS — Pyomo 6.6.2 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.6.2/library\_reference/appsi/appsi.solvers.highs.html](https://pyomo.readthedocs.io/en/6.6.2/library_reference/appsi/appsi.solvers.highs.html)  
25. Pyomo 6.4.3 with HiGHS solver \- Google Groups, accessed October 22, 2025, [https://groups.google.com/g/pyomo-forum/c/tApZf3i2cso/m/CAlNU24QCQAJ](https://groups.google.com/g/pyomo-forum/c/tApZf3i2cso/m/CAlNU24QCQAJ)  
26. APPSI — Pyomo 6.8.0 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.8.0/library\_reference/appsi/appsi.html](https://pyomo.readthedocs.io/en/6.8.0/library_reference/appsi/appsi.html)  
27. example for LP warm start? \#617 \- ERGO-Code/HiGHS \- GitHub, accessed October 22, 2025, [https://github.com/ERGO-Code/HiGHS/issues/617](https://github.com/ERGO-Code/HiGHS/issues/617)  
28. Warm-starting in HiGHS is for LP, not QP · Issue \#94 \- GitHub, accessed October 22, 2025, [https://github.com/stephane-caron/qpsolvers/issues/94](https://github.com/stephane-caron/qpsolvers/issues/94)  
29. Warm start in Pyomo \+ Xpress \- python \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/69974188/warm-start-in-pyomo-xpress](https://stackoverflow.com/questions/69974188/warm-start-in-pyomo-xpress)  
30. Highs — Pyomo 6.9.1 documentation, accessed October 22, 2025, [https://pyomo.readthedocs.io/en/6.9.1/api/pyomo.contrib.appsi.solvers.highs.Highs.html](https://pyomo.readthedocs.io/en/6.9.1/api/pyomo.contrib.appsi.solvers.highs.Highs.html)  
31. How to set Pyomo solver timeout? \- python \- Stack Overflow, accessed October 22, 2025, [https://stackoverflow.com/questions/35405642/how-to-set-pyomo-solver-timeout](https://stackoverflow.com/questions/35405642/how-to-set-pyomo-solver-timeout)  
32. HiGHS \- NEOS Server for Optimization, accessed October 22, 2025, [https://neos-server.org/neos/solvers/lp:HiGHS/LP.html](https://neos-server.org/neos/solvers/lp:HiGHS/LP.html)  
33. HiGHS \- High-performance parallel linear optimization software, accessed October 22, 2025, [https://highs.dev/](https://highs.dev/)  
34. HiGHS optimization solver \- Wikipedia, accessed October 22, 2025, [https://en.wikipedia.org/wiki/HiGHS\_optimization\_solver](https://en.wikipedia.org/wiki/HiGHS_optimization_solver)  
35. About · HiGHS Documentation, accessed October 22, 2025, [https://ergo-code.github.io/HiGHS/dev/](https://ergo-code.github.io/HiGHS/dev/)  
36. Further features · HiGHS Documentation, accessed October 22, 2025, [https://ergo-code.github.io/HiGHS/dev/guide/further/](https://ergo-code.github.io/HiGHS/dev/guide/further/)  
37. Further features · HiGHS Documentation, accessed October 22, 2025, [https://ergo-code.github.io/HiGHS/stable/guide/further/](https://ergo-code.github.io/HiGHS/stable/guide/further/)  
38. How to understand the basis of LP problems given by HiGHS solver?, accessed October 22, 2025, [https://or.stackexchange.com/questions/11090/how-to-understand-the-basis-of-lp-problems-given-by-highs-solver](https://or.stackexchange.com/questions/11090/how-to-understand-the-basis-of-lp-problems-given-by-highs-solver)  
39. Infeasible warmstart with JuMP & HiGHS \- Optimization (Mathematical) \- Julia Discourse, accessed October 22, 2025, [https://discourse.julialang.org/t/infeasible-warmstart-with-jump-highs/106869](https://discourse.julialang.org/t/infeasible-warmstart-with-jump-highs/106869)  
40. List of options · HiGHS Documentation, accessed October 22, 2025, [https://ergo-code.github.io/HiGHS/dev/options/definitions/](https://ergo-code.github.io/HiGHS/dev/options/definitions/)  
41. HiGHS Options \- AMPL Resources, accessed October 22, 2025, [https://dev.ampl.com/solvers/highs/options.html](https://dev.ampl.com/solvers/highs/options.html)  
42. Introduction to pyomo — Data Science for Energy System Modelling \- Fabian Neumann, accessed October 22, 2025, [https://fneum.github.io/data-science-for-esm/08-workshop-pyomo.html](https://fneum.github.io/data-science-for-esm/08-workshop-pyomo.html)  
43. ERGO-Code/HiGHS: Linear optimization software \- GitHub, accessed October 22, 2025, [https://github.com/ERGO-Code/HiGHS](https://github.com/ERGO-Code/HiGHS)  
44. How to display results from a solver during solving in Pyomo, accessed October 22, 2025, [https://or.stackexchange.com/questions/5787/how-to-display-results-from-a-solver-during-solving-in-pyomo](https://or.stackexchange.com/questions/5787/how-to-display-results-from-a-solver-during-solving-in-pyomo)  
45. provide several warm starts \- Google Groups, accessed October 22, 2025, [https://groups.google.com/g/gurobi/c/K7XgEF3TAyY](https://groups.google.com/g/gurobi/c/K7XgEF3TAyY)  
46. VarHint where MIP Start is not applicable (with pyomo) \- Gurobi Support, accessed October 22, 2025, [https://support.gurobi.com/hc/en-us/community/posts/360077874031-VarHint-where-MIP-Start-is-not-applicable-with-pyomo](https://support.gurobi.com/hc/en-us/community/posts/360077874031-VarHint-where-MIP-Start-is-not-applicable-with-pyomo)  
47. Warm Start of Mixed-Integer Programs for Model Predictive Control of Hybrid Systems \- Research, accessed October 22, 2025, [https://groups.csail.mit.edu/robotics-center/public\_papers/Marcucci19.pdf](https://groups.csail.mit.edu/robotics-center/public_papers/Marcucci19.pdf)  
48. Issue with Interior point method for HiGHS \- Optimization (Mathematical) \- Julia Discourse, accessed October 22, 2025, [https://discourse.julialang.org/t/issue-with-interior-point-method-for-highs/88814](https://discourse.julialang.org/t/issue-with-interior-point-method-for-highs/88814)